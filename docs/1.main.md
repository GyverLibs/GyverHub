# Документация GyverHub
На этой странице находится полный список всех классов и функций библиотеки. Более подробно по использованию можно почитать на остальных страницах документации.

## Компиляция
<details>
<summary>Настройки</summary>

**Перед подключением библиотеки** можно объявить настройки, влияющие на компиляцию библиотеки:
```cpp
#define ATOMIC_FS_UPDATE         // OTA обновление сжатым .gz файлом вместо .bin (для esp)

// BRIDGES
#define GH_NO_HTTP              // отключить встроенный модуль связи http (для esp)
#define GH_NO_WS                // отключить встроенный модуль связи ws (для esp)
#define GH_NO_MQTT              // отключить встроенный модуль связи mqtt (для esp)

#define GH_BRIDGE_AMOUNT 5      // количество мостов подключения
#define GH_WS_PORT 81           // websocket порт
#define GH_MQTT_RECONNECT 5000  // период переподключения встроенного MQTT (для esp)

// MODULES
#define GH_NO_PAIRS             // отключить поддержку типа Pairs
#define GH_NO_GET               // отключить отправку на get-топик (mqtt)
#define GH_NO_INFO              // отключить info билдер
#define GH_NO_MODULES           // отключить "модули" (все включены)
#define GH_NO_REQUEST           // отключить поддержку запросов

// FS
#define GH_NO_FS                 // отключить файловую систему (для esp)
#define GH_FETCH_CHUNK_SIZE 512  // размер чанка при скачивании с платы (для esp)
#define GH_UPL_CHUNK_SIZE 512    // размер чанка при загрузке на плату (для esp)
#define GH_FS_DEPTH 5            // глубина сканирования файловой системы (esp32)

// TRANSFER
#define GH_NO_FETCH             // отключить скачивание файлов (для esp)
#define GH_NO_UPLOAD            // отключить загрузку файлов (для esp)
#define GH_NO_OTA               // отключить ОТА обновления (для esp)
#define GH_NO_OTA_URL           // отключить ОТА по ссылке (для esp)
#define GH_REBOOT_DELAY 1500    // задержка перед перезагрузкой после OTA (для esp)

// PORTAL
#define GH_FILE_PORTAL          // загружать сайт из памяти есп (положи файлы в папку /hub/) (для esp)
#define GH_INCLUDE_PORTAL       // включить сайт в память программы, ~50кБ (не нужно загружать файлы в память) (для esp)

// HTTP
#define GH_PUBLIC_PATH "/www"          // путь к папке с файлами с HTTP доступом (для esp)
#define GH_HTTP_PORT 80                // http порт (для esp)
#define GH_CACHE_PRD "max-age=604800"  // период кеширования файлов для портала (для esp)

#define GH_NO_HTTP_TRANSFER     // отключить загрузку/скачивание/ОТА по http (для esp)
#define GH_NO_HTTP_DNS          // отключить DNS сервер (для esp)
#define GH_NO_HTTP_OTA          // отключить ОТА обновления по http (для esp)
#define GH_NO_HTTP_PUBLIC       // отключить доступ к файлам по http c ip/www (для esp)
#define GH_NO_HTTP_FETCH        // отключить скачивание файлов по http (для esp)
#define GH_NO_HTTP_UPLOAD       // отключить загрузку файлов по http (для esp)
#define GH_NO_HTTP_UPLOAD_PORTAL// отключить упрощённую загрузку файлов с ip/hub/upload_portal (для esp)
```
</details>
<details>
<summary>Платформа</summary>

Библиотека сама определяет, на какой платформе компилируется. Для проверки доступны следующие флаги:
```cpp
GH_BUILD_ESP        // любая ESP
GH_BUILD_ARDUINO    // любая не-ESP
GH_BUILD_ESP8266
GH_BUILD_ESP32
GH_BUILD_ESP32S2
GH_BUILD_ESP32S3
GH_BUILD_ESP32C3
GH_BUILD_ESP32C6
GH_BUILD_ESP32H2
```

```cpp
#include <GyverHub.h>

#ifdef GH_BUILD_ESP
// этот код будет компилироваться только для esp
#endif
```

Также в макросе `GH_PLATFORM` содержится название платформы в виде строки:
- `"ESP8266"`
- `"ESP32"`
- `"ESP32-S2"`
- `"ESP32-S3"`
- `"ESP32-C3"`
- `"ESP32-C6"`
- `"ESP32-H2"`
- `"Arduino"` для всех остальных
</details>

## GyverHub
<details>
<summary>Примечание по типам данных</summary>

Для удобства в библиотеке используются "универсальные" типы данных. Компилятор сам понимает, что передали в функцию:
- `Text` - строка в любом виде (`"строка"`, `F("строка")`, `char*`, `String`)
- `Value` - любой целочисленный и дробный тип данных + строки в любом виде
- `AnyPtr` - указатель (адрес) переменной любого типа (String, char*, все числа) + системные (Colors, Flags, Pos, Button, Log) + `Pairs`
</details>
<details>
<summary>Инициализация</summary>

```cpp
GyverHub;
GyverHub(String net);                                        // + имя сети
GyverHub(String net, String name);                           // + имя в списке устройств
GyverHub(String net, String name, String icon);              // + иконка в списке устройств
GyverHub(String net, String name, String icon, uint32_t id); // + вручную задать ID устройства
```

Иконки Font Awesome v5 Solid, бесплатный пак:
- [Список иконок](https://fontawesome.com/v5/search?o=r&m=free&s=solid)
- Вставлять в "строку" сам символ (глиф) `""` или его код `"f6ad"`
- Пустая строка `""` - отключить иконку

</details>
<details>
<summary>Система</summary>

```cpp
// настроить имя сети, название и иконку. Опционально задать свой ID устройства вида 0xXXXXXX (для esp он генерируется автоматически)
void config(String net, String name = "", String icon = "", uint32_t id = 0);

// установить версию прошивки для отображения в Info
void setVersion(String v);

// разрешить принимать широковещательные запросы (умолч. true)
void allowBroadcast(bool allow);

// установить размер буфера строки для сборки интерфейса (умолч. 1000)
void setBufferSize(uint16_t size);

// установить пин-код для открытия устройства (значение больше 1000, не может начинаться с 000..)
void setPIN(uint32_t pin);

// прочитать пин-код
uint32_t getPIN();

// запустить систему и fs 
void begin(bool startFS = true);

// остановить систему
void end();

// тикер, вызывать в loop
bool tick();

// добавить мост подключения. false если нет места
bool addBridge(gh::Bridge* bridge);
```
</details>
<details>
<summary>Статус</summary>

```cpp
bool running();     // вернёт true, если система запущена
bool focused();     // true - интерфейс устройства сейчас открыт на сайте или в приложении
bool canSend();     // доступна ли сейчас отправка (функции updateXxx и sendXxx)
```
</details>
<details>
<summary>Обработчики</summary>

```cpp
// подключить функцию-сборщик интерфейса вида f(gh::Builder& builder)
void onBuild(f);

// подключить обработчик запроса клиента вида f(gh::Request& request)
void onRequest(f);

// подключить функцию-сборщик инфо вида f(gh::Info& info)
void onInfo(f) ;

// подключить обработчик входящих сообщений с веб-консоли вида f(String str)
void onCLI(f);

// подключить обработчик пинга вида f(gh::Client& client)
void onPing(f);

// подключить обработчик получения unix времени с клиента вида f(uint32_t unix)
void onUnix(f);

// подключить обработчик получения геолокации с клиента вида f(gh::Location location)
void onLocation(f);

// подключить обработчик скачивания файлов вида f(gh::Fetcher& fetcher)
void onFetch(f);

// подключить обработчик получения данных вида f(gh::Data data)
void onData(f);

// подключить функцию-обработчик перезагрузки вида f(gh::Reboot res). Будет вызвана перед перезагрузкой
void onReboot(f);

// подключить обработчик загрузки файлов вида f(String& path). Будет вызван при сохранении файла
void onUpload(f);

// безопасная загрузка файлов (загружать во временный файл) (умолч. включен, true)
void safeUpload(bool state);
```
</details>
<details>
<summary>Отправка</summary>

```cpp
// запросить геолокацию (придёт в onLocation)
void requestLocation(gh::Client* client, bool highAccuracy = false);

// отправить текст в веб-консоль. Опционально цвет
void sendCLI(Text str, gh::Colors col = gh::Colors::Default, gh::Client* client = nullptr);

// обновить панель управления в приложении у всех клиентов или выбранного
void sendRefresh(gh::Client* client = nullptr);

// выполнить js код
void sendScript(Text script, gh::Client* client = nullptr);

// отправить действие (обновить файл, вызвать Confirm/Prompt)
void sendAction(Text name, gh::Client* client = nullptr);

// отправить пуш уведомление
void sendPush(Text text, gh::Client* client = nullptr);

// отправить всплывающее уведомление
void sendNotice(Text text, gh::Colors col = gh::Colors::Green, gh::Client* client = nullptr);

// показать окно с ошибкой
void sendAlert(Text text, gh::Client* client = nullptr);
```
</details>
<details>
<summary>Обновление</summary>

```cpp
// обновить виджет. Указать имя виджета (или список), клиента (опционально)
gh::UpdateInline update(Text name, gh::Client* client = nullptr);

// отправить value update на имя виджета int/string/bool
void sendUpdate(Text name, Value value, gh::Client* client = nullptr);

// отправить value update на имя виджета float
void sendUpdate(Text name, double value, uint8_t dec, gh::Client* client = nullptr);

// отправить value update по имени компонента (значение будет прочитано в build). Нельзя вызывать из build. Имена можно передать списком через ;
void sendUpdate(Text name, gh::Client* client = nullptr);
```
</details>
<details>
<summary>MQTT</summary>

```cpp
// автоматически отправлять новое состояние на get-топик при изменении через set (умолч. false)
void sendGetAuto(bool state);

// отправить имя-значение на get-топик (MQTT) int/string/bool
void sendGet(Text name, Value value);

// отправить имя-значение на get-топик (MQTT) float
void sendGet(Text name, double value, uint8_t dec);

// отправить значение по имени компонента на get-топик (MQTT) (значение будет прочитано в build). Имена можно передать списком через ;
void sendGet(String name);

// отправить MQTT LWT команду на включение/выключение
void sendStatus(bool status);

// топик статуса для отправки
String topicStatus();

// общий топик для подписки
String topicDiscover();

// топик устройства для подписки
String topicHub();
```
</details>
<details>
<summary>Отправка на устройство</summary>

```cpp
// отправить устройству device_id данные с именем name и значением value
void sendData(uint32_t device_id, gh::Bridge* bridge, Text name, Value value);

// отправить всем устройствам данные с именем name и значением value
void sendDataAll(gh::Bridge* bridge, Text name, Value value);

// отправить устройству device_id данные с именем name и значением value
void sendData(uint32_t device_id, gh::Bridge* bridge, Text name, double value, uint8_t dec);

// отправить всем устройствам данные с именем name и значением value
void sendDataAll(gh::Bridge* bridge, Text name, double value, uint8_t dec);
```
</details>
<details>
<summary>Чтение билдера</summary>

```cpp
// получить полный JSON пакет панели управления. Флаг enclose true - обернуть в результат в []
String getUI(bool enclose = true);

// получить JSON объект {имя:значение, ...} виджетов (из билдера)
String getValues();

// получить значение компонента по имени (из билдера)
String getValue(Text name);
```
</details>
<details>
<summary>Публичные члены</summary>

```cpp
uint8_t menu;   // номер текущего пункта меню
String net = "";
String name = "";
String icon = "";
String version = "";
uint32_t id;
gh::Bridge* bridges[GH_BRIDGE_AMOUNT];
Modules modules;
gh::HubStream stream;
HubMQTT mqtt;
```
</details>

## Билдер
<details>
<summary>Контейнеры</summary>

```cpp
// если первый символ в тексте - иконка, то добавляется иконка

// строка
// начать строку. Всегда возвращает true
bool beginRow(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginRow_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// закончить строку
void endRow();

// закончить и начать строку
bool nextRow(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextRow_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// столбец
// начать столбец. Всегда возвращает true
bool beginCol(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginCol_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// закончить и начать столбец
bool nextCol(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextCol_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// закончить столбец
void endCol();

// спойлер
bool beginSpoilerRow(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginSpoilerRow_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
void endSpoilerRow();
bool nextSpoilerRow(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextSpoilerRow_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

bool beginSpoilerCol(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginSpoilerCol_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextSpoilerCol(uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextSpoilerCol_(Text name, uint8_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
void endSpoilerCol();

// пустой виджет, можно использовать как отступ
Widget& Space(uint16_t width = 1, uint16_t height = 1);

// начать кастомный контейнер
bool beginRow(Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginRow_(Text name, Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginCol(Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool beginCol_(Text name, Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// следующий кастомный контейнер
bool nextRow(Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextRow_(Text name, Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextCol(Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
bool nextCol_(Text name, Text wtype, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// закончить любой контейнер
void endContainer();

// объекты контейнеров
Row(Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
Row_(Text name, Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
Col(Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
Col_(Text name, Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
SpoilerRow(Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
SpoilerRow_(Text name, Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
SpoilerCol(Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);
SpoilerCol_(Text name, Builder& b, uint16_t width = 0, Text label = "", Color color = Colors::Default, uint8_t fontsize = 23);

// переключатель видимости
Show(Builder& b, bool en);
```
</details>
<details>
<summary>Виджеты</summary>

```cpp
// =================== МЕНЮ ====================
// Меню. Передать пункты меню списком "пункт1;пункт2" + attach, click
// если первый символ - иконка, то добавляется иконка
Widget& Menu(Text text);

// =================== ВВОД ====================
// Поле ввода текста. Параметры: value (текст), color, regex, maxLen, disabled, attach, click + параметры виджета
Widget& Input(AnyPtr ptr);
Widget& Input_(Text name, AnyPtr ptr);

// Поле ввода текста. Параметры: value (текст), rows, maxLen, disabled, attach, click + параметры виджета
Widget& InputArea(AnyPtr ptr);
Widget& InputArea_(Text name, AnyPtr ptr);

// Поле ввода пароля. Параметры: value (текст), color, regex, maxLen, disabled, attach, click + параметры виджета
Widget& Pass(AnyPtr ptr);
Widget& Pass_(Text name, AnyPtr ptr);

// Всплывающее окно подтверждения. Параметры: text (подпись), attach, click. Для активации отправь обновление action()
Widget& Confirm(AnyPtr ptr);
Widget& Confirm_(Text name, AnyPtr ptr);

// Всплывающее окно ввода. Параметры: value (значение), text (подпись), attach, click. Для активации отправь обновление action()
Widget& Prompt(AnyPtr ptr);
Widget& Prompt_(Text name, AnyPtr ptr);

// Дата. Параметры: value(unix), color, disabled, attach, click + параметры виджета
Widget& Date(AnyPtr ptr);
Widget& Date_(Text name, AnyPtr ptr);

// Время. Параметры: value(unix), color, disabled, attach, click + параметры виджета
Widget& Time(AnyPtr ptr);
Widget& Time_(Text name, AnyPtr ptr);

// Дата и время. Параметры: value(unix), color, disabled, attach, click + параметры виджета
Widget& DateTime(AnyPtr ptr);
Widget& DateTime_(Text name, AnyPtr ptr);

// Слайдер. Параметры: value (значение), color, range, unit, icon, disabled, attach, click + параметры виджета
Widget& Slider(AnyPtr ptr);
Widget& Slider_(Text name, AnyPtr ptr);

// Спиннер. Параметры: value (значение), range, unit, disabled, attach, click + параметры виджета
// если первый символ - иконка, то добавляется иконка
Widget& Spinner(AnyPtr ptr);
Widget& Spinner_(Text name, AnyPtr ptr);

// Выпадающий список. Параметры: value (номер пункта), text (список), color, disabled, attach, click + параметры виджета
Widget& Select(AnyPtr ptr);
Widget& Select_(Text name, AnyPtr ptr);

// Цвет. Параметры: value (цвет), disabled, attach, click + параметры виджета
Widget& Color(AnyPtr ptr);
Widget& Color_(Text name, AnyPtr ptr);

// Выключатель. Параметры: value (состояние), color, disabled, attach, click + параметры виджета
Widget& Switch(AnyPtr ptr);
Widget& Switch_(Text name, AnyPtr ptr);

// Выключатель. Параметры: value (состояние), icon, color, fontSize, disabled, attach, click + параметры виджета
Widget& SwitchIcon(AnyPtr ptr);
Widget& SwitchIcon_(Text name, AnyPtr ptr);

// Вкладки. Параметры: value (выбранная), text (список), color, disabled, attach, click + параметры виджета. text не обновляется
// если первый символ - иконка, то добавляется иконка
Widget& Tabs(AnyPtr ptr);
Widget& Tabs_(Text name, AnyPtr ptr);

// Теги. Параметры: value (текст-список ;), color, disabled, attach, click + параметры виджета
Widget& Tags(AnyPtr ptr);
Widget& Tags_(Text name, AnyPtr ptr);

// Кнопка. Параметры: icon, color, fontSize, disabled, attach, click + параметры виджета
Widget& Button(gh::Button* ptr);
Widget& Button_(Text name, gh::Button* ptr);

// Кнопки выбора. Параметры: value (флаги), text (список), color, disabled, attach, click + параметры виджета
// если первый символ - иконка, то добавляется иконка
Widget& Flags(gh::Flags* ptr);
Widget& Flags_(Text name, gh::Flags* ptr);

// Джойстик. keep - возвращать в центр, exp - экспоненциальные значения. Параметры: color + параметры виджета
Widget& Joystick(Pos* pos = nullptr, bool keep = 0, bool exp = 0);
Widget& Joystick_(Text name, Pos* pos = nullptr, bool keep = 0, bool exp = 0);

// Крестовина. Параметры: color + параметры виджета
Widget& Dpad(Pos* pos = nullptr);
Widget& Dpad_(Text name, Pos* pos = nullptr);

// Карта. Параметры: disabled, attach, click + параметры виджета
Widget& Map(gh::Geo* geo = nullptr, gh::Layer layer = gh::Layer::OSM);
Widget& Map_(Text name, gh::Geo* geo = nullptr, gh::Layer layer = gh::Layer::OSM);

// Холст. Ширина, длина. Только параметры виджета
Widget& Canvas(uint16_t width = 400, uint16_t height = 300, Pos* pos = nullptr);
Widget& Canvas_(Text name, uint16_t width = 400, uint16_t height = 300, Pos* pos = nullptr);

// =================== ВЫВОД ====================
// Заголовок. Параметры: value (текст), icon, color, align, fontSize + size виджета
Widget& Title(Value text);
Widget& Title_(Text name, Value text);
Widget& Title_(Text name, Pairs* pairs);

// Надпись. Параметры: value (текст), icon, color, align, fontSize + параметры виджета
Widget& Label(Value text);
Widget& Label_(Text name, Value text);
Widget& Label_(Text name, Pairs* pairs);

// Окно с текстом. Параметры: value (текст), rows + параметры виджета
Widget& Text(Value text);
Widget& Text_(Text name, Value text);
Widget& Text_(Text name, Pairs* pairs);

// Окно с текстом. Параметры: value (путь), rows + параметры виджета
Widget& TextFile(Value text);
Widget& TextFile_(Text name, Value text);
Widget& TextFile_(Text name, Pairs* pairs);

// Дисплей. Параметры: value (текст), color, fontSize, rows + параметры виджета
Widget& Display(Value text);
Widget& Display_(Text name, Value text);
Widget& Display_(Text name, Pairs* pairs);

// Картинка. Параметры: value (путь) + параметры виджета
Widget& Image(Text text);
Widget& Image_(Text name, Text text);
Widget& Image_(Text name, Pairs* pairs);

// Лог. value(текст), rows + параметры виджета
Widget& Log(gh::Log* ptr);
Widget& Log_(Text name, gh::Log* ptr);

// Светодиод. Параметры: value (состояние 1/0), color + параметры виджета
Widget& LED(AnyPtr ptr);
Widget& LED_(Text name, AnyPtr ptr);

// Светодиод-иконка. Параметры: value (состояние 1/0), icon, fontSize, color + параметры виджета
Widget& Icon(AnyPtr ptr);
Widget& Icon_(Text name, AnyPtr ptr);

// Индикаторная шкала. Параметры: value (значение), range, unit, color + параметры виджета
Widget& Gauge(AnyPtr ptr);
Widget& Gauge_(Text name, AnyPtr ptr);

// Индикаторная шкала круглая. Параметры: value (значение), range, unit, color + параметры виджета
Widget& GaugeRound(AnyPtr ptr);
Widget& GaugeRound_(Text name, AnyPtr ptr);

// Индикаторная шкала линейная. Параметры: value (значение), icon, range, unit, color + параметры виджета
Widget& GaugeLinear(AnyPtr ptr);
Widget& GaugeLinear_(Text name, AnyPtr ptr);

// Таблица. Параметры: value (текст или путь) + параметры виджета
// text: таблица в формате CSV - разделитель столбцов ; разделитель строк \n
// width: ширина, список чисел в процентах (например "30;30;50")
// align: выравнивание, список из left | center | right (например "left;right")
Widget& Table(Text text, Text width, Text align);
Widget& Table_(Text name, Text text, Text width, Text align);

// ===================== CUSTOM =====================
// HTML код в виджет. Параметры: (код или /путь.html) + параметры виджета
Widget& HTML(Value text);
Widget& HTML_(Text name, Value text);

// плагин в виде js кода (см. доку) или путь к файлу
Widget& Plugin(Text wtype, Text text);

// кастомный виджет, указать тип из класса виджета (см. доку). Можно использовать любые параметры виджета
Widget& Widget(Text wtype);
Widget& Widget(Text wtype, Value text);
Widget& Widget(Text wtype, AnyPtr ptr);
Widget& Widget_(Text name, Text wtype);
Widget& Widget_(Text name, Text wtype, Value text);
Widget& Widget_(Text name, Text wtype, AnyPtr ptr);

// добавить виджеты из JSON (текст или путь.json) в ряд. Можно добавить size
ghc::Widget& uiRow(Text path);

// добавить виджеты из JSON (текст или путь.json) из файла в колонку. Можно добавить size
ghc::Widget& uiCol(Text path);

// невидимый компонент для mqtt и json ui. Любые параметры + attach, click
Widget& Dummy(Value text);
Widget& Dummy_(Text name, Value text);
```
</details>
<details>
<summary>Параметры виджетов</summary>

```cpp
// ===================== BLOCK =====================
// Ширина (относительно) и высота (px) виджета
Widget& size(uint16_t width, uint16_t height = 0);

// Заголовок виджета
Widget& label(Text str);

// Убрать заголовок виджета
Widget& noLabel(bool nolabel = true);

// Дополнительный заголовок виджета справа
Widget& suffix(Text str);

// Убрать задний фон виджета
Widget& noTab(bool notab = true);

// Сделать виджет квадратным
Widget& square(bool square = true);

// Отключить виджет
Widget& disabled(bool disable = true);

// Подсказка виджета. Пустая строка - убрать подсказку
Widget& hint(Text str);

// ===================== CUSTOM =====================
// int/string/bool поле
Widget& param(Text key, Value val);

// float поле
Widget& param(Text key, double val, uint8_t dec);

// ===================== VALUE =====================
// привязать переменную как значение
Widget& valueVar(AnyPtr data);

// int/string/bool значение
Widget& value(Value val);

// float значение
Widget& value(double val, uint8_t dec);

// Geo значение
Widget& value(Geo geo);

// ===================== TEXT =====================
// текст
Widget& text(Text str);

// иконка (glyph или unicode) https://fontawesome.com/v6/search?o=r&m=free&s=solid
Widget& icon(Text str);

// максимальная длина текста
Widget& maxLen(uint16_t len);

// ===================== MISC =====================
// количество строк поля текста
Widget& rows(uint16_t rows);

// regex для Input и Pass
Widget& regex(Text str);

// выравнивание текста для label/title
Widget& align(gh::Align align);

// минимум, максимум и шаг изменения значения (float)
Widget& range(double min, double max, double step, uint8_t dec = 2);

// минимум, максимум и шаг изменения значения (целые числа)
template <typename T>
Widget& range(T min, T max, T step);

// единицы измерения
Widget& unit(Text str);

// размер шрифта/кнопки
Widget& fontSize(uint16_t size);

// цвет uint32_t 24 бит
Widget& color(uint32_t color);

// цвет gh::Colors
Widget& color(gh::Colors col);

// Действие (вызвать Confirm/Prompt)
Widget& action(bool act = 1);

// обновить файл
Widget& update(bool upd = 1);

// ===================== ACTION =====================
// Проверка на клик по виджету
bool click();

// ===================== ATTACH =====================
// Подключить функцию вида void f()
Widget& attach(void (*cb)());

// Подключить функцию вида void f(gh::Build& build)
Widget& attach(void (*cb)(gh::Build& build));

// Подключить функцию вида void f(gh::Builder& build)
Widget& attach(void (*cb)(gh::Builder& build), gh::Builder& b);

// Подключить gh::Flag* флаг
Widget& attach(gh::Flag* flag);

// Подключить bool* флаг
Widget& attach(bool* flag);
```
</details>
<details>
<summary>Прочие методы</summary>

```cpp
// обновить панель управления у текущего клиента (по действию с виджета)
void refresh();

// был ли запрос на обновление панели управления
bool isRefresh();

// включить/выключить вывод виджетов (только для запроса виджетов)
bool show(bool en = true);

// было изменено значение виджета (сигнал на сохранение)
bool changed();

// был клик по предыдущему виджету
bool click();

// номер текущего пункта меню
uint8_t menu();
```
</details>

## Canvas
<details>
<summary>Константы</summary>

```cpp
MITER,
ROUND,
BEVEL,
SQUARE,
PROJECT,
CORNER,
CORNERS,
CENTER,
RADIUS,
LEFT,
RIGHT,
TOP,
BOTTOM,
BASELINE,
```
</details>
<details>
<summary>Класс</summary>

```cpp
// ================ КОНСТРУКТОР =================
Canvas();
Canvas(gh::Builder& b);

// =================== SYSTEM ===================
// подключить внешний буфер
void setBuffer(ghc::Packet* packet);

// добавить строку кода на js
void custom(Text text);

// true - координаты в пикселях, false - приведённые координаты (метры для карты Map)
void pixelScale(bool pix);

// =================== BACK ===================

// очистить
void clear();

// залить полотно указанным цветом (цвет, прозрачность), умолч. 0xddd
void background(const Color& color, uint8_t a = 255);
void background(uint32_t hex, uint8_t a = 255);
void background(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255);

// =================== FILL ===================

// выбрать цвет заливки (цвет, прозрачность), умолч. 0xfff
void fill(const Color& color, uint8_t a = 255);
void fill(uint32_t hex, uint8_t a = 255);
void fill(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255);

// отключить заливку
void noFill();

// =================== STROKE ===================

// выбрать цвет обводки (цвет, прозрачность), умолч. 0x000
void stroke(const Color& color, uint8_t a = 255);
void stroke(uint32_t hex, uint8_t a = 255);
void stroke(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255);

// отключить обводку
void noStroke();

// толщина обводки
void strokeWeight(int v);

// соединение линий: MITER (умолч.), ROUND, BEVEL
// https://processing.org/reference/strokeJoin_.html
void strokeJoin(cv mode);

// края линий: ROUND (умолч.), SQUARE, PROJECT
// https://processing.org/reference/strokeCap_.html
void strokeCap(cv mode);

// =================== MODE ===================

// режим прямоугольника: CORNER (умолч.), CORNERS, CENTER, RADIUS
// https://processing.org/reference/rectMode_.html
void rectMode(cv mode);

// режим окружности: CENTER (умолч.), RADIUS, CORNER, CORNERS
// https://processing.org/reference/ellipseMode_.html
void ellipseMode(cv mode);

// =================== IMAGE ===================

// режим изображения: CORNER (умолч.), CORNERS, CENTER
// https://processing.org/reference/imageMode_.html
void imageMode(cv mode);

// вывести изображение по пути (из файла или из Интернета)
// https://processing.org/reference/image_.html
void image(Text path, long x, long y);
void image(Text path, long x, long y, long w);
void image(Text path, long x, long y, long w, long h);

void image(Text path, Geo xy);
void image(Text path, Geo xy, long w);
void image(Text path, Geo xy, long w, long h);

// =================== TEXT ===================

// шрифт
void textFont(Text font);

// размер шрифта
void textSize(int size);

// выравнивание текста (LEFT (умолч.), CENTER, RIGHT), (BASELINE (умолч.), TOP, BOTTOM, CENTER)
// https://processing.org/reference/textAlign_.html
void textAlign(cv x, cv y);

// вывести текст
void text(Text txt, long x, long y);
void text(Text txt, Geo xy);

// =================== PRIMITIVES ===================
// точка
// https://processing.org/reference/point_.html
void point(long x, long y);
void point(Geo xy);

// линия
// https://processing.org/reference/line_.html
void line(long x1, long y1, long x2, long y2);
void line(Geo xy1, Geo xy2);

// прямоугольник
// https://processing.org/reference/rect_.html
void rect(long x, long y, long w, long h);
void rect(long x, long y, long w, long h, long r);
void rect(long x, long y, long w, long h, long tl, long tr, long br, long bl);

void rect(Geo xy, long w, long h);
void rect(Geo xy, long w, long h, long r);
void rect(Geo xy, long w, long h, long tl, long tr, long br, long bl);

// квадрат
// https://processing.org/reference/square_.html
void square(long x, long y, long size);
void square(Geo xy, long size);

// треугольник
// https://processing.org/reference/triangle_.html
void triangle(long x0, long y0, long x1, long y1, long x2, long y2);
void triangle(Geo xy0, Geo xy1, Geo xy2);

// четырёхугольник
// https://processing.org/reference/quad_.html
void quadrangle(long x0, long y0, long x1, long y1, long x2, long y2, long x3, long y3);
void quadrangle(Geo xy0, Geo xy1, Geo xy2, Geo xy3);

// дуга
// https://processing.org/reference/arc_.html
void arc(long x, long y, long w, long h, float start, float stop);
void arc(Geo xy, long w, long h, float start, float stop);

// эллипс
// https://processing.org/reference/ellipse_.html
void ellipse(long x, long y, long w, long h);
void ellipse(Geo xy, long w, long h);

// окружность
// https://processing.org/reference/circle_.html
void circle(long x, long y, long r);
void circle(Geo xy, long r);

// кривая Безье
// https://processing.org/reference/bezier_.html
void bezier(long x1, long y1, long x2, long y2, long x3, long y3, long x4, long y4);
void bezier(Geo xy1, Geo xy2, Geo xy3, Geo xy4);

// =================== SHAPE ===================
// начать фигуру
void beginShape();

// закончить фигуру
void endShape(bool close = 0);

// следующая точка фигуры
void vertex(long x, long y);
void vertex(Geo xy);

// следующая точка фигуры безье
void bezierVertex(long xa1, long ya1, long xa2, long ya2, long xe, long ye);
void bezierVertex(Geo anch1, Geo anch2, Geo endp);

// =================== CANVAS ===================
// вращать область рисования (в радианах)
// https://processing.org/reference/rotate_.html
void rotate(float rad);

// перемещать область рисования
// https://processing.org/reference/translate_.html
void translate(long x, long y);
void translate(Geo xy);

// сохранить настройки рисования
// https://processing.org/reference/push_.html
void push();

// восстановить настройки рисования
// https://processing.org/reference/pop_.html
void pop();
```
</details>
<details>
<summary>Обновление</summary>

```cpp
gh::CanvasUpdate(Text name, GyverHub* hub, Client* client = nullptr);

// отправить
void send();
```
</details>

## Типы данных
<details>
<summary>gh::Align</summary>

```cpp
Left
Center
Right
```
</details>
<details>
<summary>gh::Layer</summary>

```cpp
OSM
GoogleStreet
GoogleSatellite
GoogleHybrid
```
</details>
<details>
<summary>gh::Action</summary>

```cpp
UI
Read
Set
Get
None
```
</details>
<details>
<summary>gh::Reboot</summary>

```cpp
None
Button
Ota
OtaUrl
```
</details>
<details>
<summary>gh::Connection</summary>

```cpp
Serial
Bluetooth
WS
MQTT
HTTP
HTTP_WS
Telegram
Custom
System
```
</details>
<details>
<summary>gh::CMD</summary>

```cpp
UI
Ping
Unfocus
Info
Files
Format
Reboot
FetchNext
Data
Set
Get
Read
CLI
Delete
Rename
Create
FsAbort
Fetch
Upload
UploadChunk
Ota
OtaChunk
OtaUrl
Unix
Search
Discover
Location
Unknown
```
</details>
<details>
<summary>gh::Colors</summary>

```cpp
Red = 0xcb2839,
Orange = 0xd55f30,
Yellow = 0xd69d27,
Green = 0x37A93C,
Mint = 0x25b18f,
Aqua = 0x2ba1cd,
Blue = 0x297bcd,
Violet = 0x825ae7,
Pink = 0xc8589a,
Default = 0xffffffff,
```
</details>
<details>
<summary>gh::Module</summary>

```cpp
ModUI
ModInfo
ModSet
ModRead
ModGet
ModData
ModReboot
ModFiles
ModFormat
ModDelete
ModRename
ModCreate
ModFetch
ModUpload
ModOta
ModOtaUrl
```
</details>

## Классы
<details>
<summary>gh::Location</summary>

```cpp
// время, когда получена позиция
uint32_t stamp = 0;

// Широта в градусах
float lat = 0;

// Долгота в градусах
float lon = 0;

// Высота над уровнем моря в метрах
float alt = 0;

// Скорость движения в м/с
float speed = 0;

// Направление движения в градусах от севера по часовой стрелке
float heading = 0;

// Точность измерений в метрах
float accuracy = 0;

// клиент
Client& client;
```
</details>
<details>
<summary>gh::Geo</summary>

```cpp
Geo();
Geo(float lat, float lon);

float lat;
float lon;

// расстояние до другой точки в метрах
float dist(const Geo& geo);
```
</details>
<details>
<summary>gh::Data</summary>

```cpp
Text name;
Text value;
Client& client;
```
</details>
<details>
<summary>gh::Button</summary>

```cpp
// состояние кнопки изменилось
bool changed();

// состояние кнопки (1 нажата, 0 отпущена)
bool state();

// клик по кнопке
bool click();
```
</details>
<details>
<summary>gh::Color</summary>

```cpp
uint8_t r = 0, g = 0, b = 0;

Color(uint8_t gray);
Color(Colors color);
Color(uint32_t hex, bool gray = false);
Color(uint8_t v1, uint8_t v2, uint8_t v3, bool hsv = false);

// установить RGB цвет
void setRGB(uint8_t nr, uint8_t ng, uint8_t nb);

// установить серый цвет 0.. 255
void setGray(uint8_t gray);

// установить цвет 24-бит RGB
void setHEX(uint32_t hex);

// установить цвет 16-бит RGB
void set565(uint16_t col);

// установить цвет HSV
void setHSV(uint8_t h, uint8_t s, uint8_t v);

// установить цвет по радуге (0.. 255)
void setHue(uint8_t color);

// получить 24-бит RGB цвет
uint32_t getHEX();

// получить 16-бит RGB цвет
uint16_t get565();

// static
static Color fromRGB(uint8_t r, uint8_t g, uint8_t b);
static Color fromHSV(uint8_t h, uint8_t s, uint8_t v);
static Color fromHEX(uint32_t hex);
static Color fromGray(uint8_t gray);
static Color fromHue(uint8_t hue);
static Color from565(uint16_t rgb565);
```
</details>
<details>
<summary>gh::CSVFile</summary>

```cpp
// создать таблицу (путь, столбцов, строк)
CSVFile(const char* path, uint8_t cols, uint16_t rows = 0);

// добавить int/string/bool
CSVFile& add(Value value);

// добавить float
CSVFile& add(double value, uint8_t dec);

// завершить строку
void endRow(bool close = true);

// получить значение ячейки (столбец, строка)
String get(uint8_t col, uint16_t row);

// очистить таблицу
void clear();

// пересчитать количество строк (после ручного изменения)
void update();
```
</details>
<details>
<summary>gh::CSV</summary>

```cpp
// создать таблицу (столбцов, строк)
CSV(uint8_t cols, uint16_t rows = 0);

// зарезервировать строку
void reserve(uint32_t res);

// добавить int/string/bool
CSV& add(Value value);

// добавить float
CSV& add(double value, uint8_t dec);

// завершить строку
void endRow();

// получить значение ячейки (столбец, строка)
String get(uint8_t col, uint16_t row);

// очистить таблицу
void clear();

// пересчитать количество строк (после ручного изменения)
void update();
```
</details>
<details>
<summary>gh::Flag</summary>

```cpp
bool changed();
```
</details>
<details>
<summary>gh::Flags</summary>

```cpp
Flags();
Flags(uint16_t nflags);

void clear(uint8_t idx);
void set(uint8_t idx);
void write(uint8_t idx, uint8_t val);
uint8_t get(uint8_t idx);
String toString();
```
</details>
<details>
<summary>gh::Log</summary>

```cpp
// начать и указать размер буфера
void begin(int n = 64);

// остановить
void end();

// прочитать в строку
void read(String* s, bool esc = false);

// прочитать строкой
String read();

// очистить
void clear();

// есть данные
bool available();

// запущен
bool state();

// длина
int length();
```
</details>
<details>
<summary>gh::Pos</summary>

```cpp
bool changed();

// расстояние до точки
uint16_t dist(int16_t x1, int16_t y1);

// точка лежит внутри прямоугольника
bool inRect(int16_t rx, int16_t ry, uint16_t w, uint16_t h);

// точка лежит внутри окружности
bool inCircle(int16_t cx, int16_t cy, uint16_t r);

// координата x
int16_t x = 0;

// координата y
int16_t y = 0;
```
</details>
<details>
<summary>gh::Timer</summary>

```cpp
// указать время. Таймер сам запустится в режиме интервала!
Timer(uint32_t ms, uint32_t seconds = 0, uint32_t minutes = 0, uint32_t hours = 0, uint32_t days = 0);

// =========== MANUAL ===========
// установить период
void setTime(uint32_t ms, uint32_t seconds = 0, uint32_t minutes = 0, uint32_t hours = 0, uint32_t days = 0);

// получить период
uint32_t getTime();

// установить функцию опроса времени millis/micros/свою unsigned long
void setSource(Uptime source);

// удерживать фазу (умолч. false) [false: tmr = uptime, true: tmr += prd]
void keepPhase(bool keep);

// запустить в режиме таймаута
void startTimeout();

// запустить в режиме интервала
void startInterval();

// перезапустить в текущем режиме
void restart();

// остановить
void stop();

// состояние (запущен?)
bool state();

// подключить функцию-обработчик вида void f()
void attach(TimerCallback callback);

// отключить функцию-обработчик
void detach();

// тикер, вызывать в loop. Вернёт true, если сработал
bool tick();

// осталось времени
uint32_t timeLeft();
```
</details>

## Системные классы
<details>
<summary>gh::Bridge</summary>

```cpp
Bridge(void* hub, Connection conn, ghc::ParseHook parse);

// настроить
void config(void* hub, Connection conn, ghc::ParseHook parse);

// парсить url=data или url + data отдельно
void parse(Text url, Text data);

// установить режим (приём, передача, ответ)
void setMode(bool parse, bool send, bool answer);

// может принимать
bool canParse();

// может отправлять
bool canSend();

virtual void begin(){};
virtual void end(){};
virtual void tick(){};
virtual void send(BridgeData& data){};

bool isAnswer();            // true если сейчас идёт парсинг (это ответ приложению)
Connection connection;    // тип подключения
void setFocus();            // установить focus
void clearFocus();          // снять focus
bool getFocus();            // получить focus
```
</details>
<details>
<summary>gh::Build</summary>

```cpp
const Action action;    // тип билда
Client& client;         // клиент
const Text name;       // имя компонента
const Text value;      // значение компонента
bool isSet();           // билд-действие
bool isUI();            // билд-запрос виджетов
Color valueColor();     // получить значение как Color
Flags valueFlags();     // получить значение как Flags
Pos valuePos();         // получить значение как Pos
```
</details>
<details>
<summary>gh::Client</summary>

```cpp
// тип подключения
Connection connection;

// id клиента
uint32_t id;
```
</details>
<details>
<summary>gh::FS</summary>

```cpp
File openRead(String path);
File openAdd(String path);
File openWrite(String path);
bool begin();
void end();
bool mounted();
void format();
bool remove(String path, bool remdir = true);
bool rename(String from, String to);
bool exists(String path);
uint64_t freeSpace();
uint64_t totalSpace();
uint64_t usedSpace();
void mkdir(String path);
void rmdir(String path);
void listDir(String& str, String path, char div);
void showFiles(String& answ, String path, uint8_t levels = 0, uint32_t* count = nullptr);
```
</details>
<details>
<summary>ghc::Modules</summary>

```cpp
uint16_t mods = 0;

void set(uint16_t nmods);
void clear(uint16_t nmods);

void setAll();
void clearAll();
bool read(gh::Module m);
bool read(uint16_t m);
```
</details>
<details>
<summary>gh::Request</summary>

```cpp
Client& client; // клиент
const CMD cmd;  // событие
Text name;   // имя
Text value;  // значение
bool broadcast; // широковещательный запрос
```
</details>
<details>
<summary>gh::Fetcher</summary>

```cpp
// отправить файл по пути
void fetchFile(const char* path);

// отправить файл
template <typename T>
void fetchFile(T& file);

// отправить сырые данные
void fetchBytes(uint8_t* bytes, uint32_t len);

// отправить сырые данные из PGM
void fetchBytes_P(const uint8_t* bytes, uint32_t len);

// true - начало скачивания
bool start;

// путь к скачиваемому файлу
Text path;
```
</details>
<details>
<summary>gh::Info</summary>

```cpp
// добавить int/string/bool поле в info
void add(Text label, Value val);

// добавить float поле в info
void add(Text label, double val, uint8_t dec);

const Client& client;
Type type;

// Info::Type
// Version
// Network
// Memory
// System
```
</details>
<details>
<summary>gh::Update</summary>

```cpp
Update(GyverHub* hub, Client* client = nullptr);

// начать обновление по имени виджета (или список)
Widget& update(Text name);

// отправить пакет
void send();

// текущий виджет для установки значений
Widget widget;
```
</details>

## Функции
<details>
<summary>Read</summary>

```cpp
// получить текстовое значение типа CMD для вывода в порт
FSTR gh::readCMD(CMD cmd);

// получить текстовое значение типа Connection для вывода в порт
FSTR gh::readConnection(Connection connection);

// получить текстовое значение типа Action для вывода в порт
FSTR gh::readAction(Action action);

// получить текстовое значение типа Reboot для вывода в порт
FSTR gh::readReboot(Reboot reason);
```
</details>
<details>
<summary>Position</summary>

```cpp
// расстояние между двумя точками
uint16_t gh::dist(int16_t x0, int16_t y0, int16_t x1, int16_t y1);

// точка лежит внутри прямоугольника (координаты угла и размеры)
bool gh::inRect(int16_t x, int16_t y, int16_t rx, int16_t ry, uint16_t w, uint16_t h);

// точка лежит внутри окружности (координаты центра и радиус)
bool gh::inCircle(int16_t x, int16_t y, int16_t cx, int16_t cy, uint16_t r);
```
</details>